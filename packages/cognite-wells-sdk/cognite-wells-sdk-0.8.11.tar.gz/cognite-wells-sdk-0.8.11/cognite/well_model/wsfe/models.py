# generated by datamodel-codegen:
#   filename:  wsfe.yaml

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Union

from pydantic import Field

from cognite.well_model.base_model import WellsBaseModel


class ProcessIdItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[str]


class FileType(Enum):
    las = "las"
    dlis = "dlis"
    asc = "asc"


class ProcessStatus(Enum):
    ready = "ready"
    processing = "processing"
    done = "done"
    error = "error"


class Severity(Enum):
    info = "info"
    warning = "warning"
    error = "error"


class JobSource(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    file_external_id: str = Field(..., alias="fileExternalId")
    file_type: FileType = Field(..., alias="fileType")
    source: Optional[str] = Field(
        None,
        description="Original source of the data, required when using the `writeToWdl` option. Must be registered in WDL before use.",
    )


class ExternalIdMapping(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    cdf: str
    wdl: str


class Matches(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matches: Dict[str, str]


class ProcessingLog(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    timestamp: datetime
    severity: Severity
    message: str


class ExistingAsset(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    well: ExternalIdMapping
    wellbore: ExternalIdMapping


class JobDestination(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    data_set_external_id: str = Field(..., alias="dataSetExternalId")
    sequence_external_id_prefix: Optional[str] = Field(None, alias="sequenceExternalIdPrefix")
    existing_asset: Optional[ExistingAsset] = Field(None, alias="existingAsset")


class SubmitJob(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    source: JobSource
    destination: JobDestination
    contains_trajectory: bool = Field(..., alias="containsTrajectory")


class ProcessState(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    process_id: str = Field(..., alias="processId")
    status: ProcessStatus
    file_external_id: str = Field(..., alias="fileExternalId")
    created_sequences: List[str] = Field(..., alias="createdSequences")
    created_assets: List[str] = Field(..., alias="createdAssets")
    logs: List[ProcessingLog]


class ProcessStateItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: Optional[List[ProcessState]] = None


class SubmitRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    write_to_wdl: Optional[bool] = Field(False, alias="writeToWdl")
    create_assets: Optional[bool] = Field(
        False,
        alias="createAssets",
        description="If both createAssets and contextualizeWithAssets is true, it will\ncreate assets to contextualize the sequences with.",
    )
    contextualize_with_assets: Optional[bool] = Field(
        False,
        alias="contextualizeWithAssets",
        description="If set to true, it will try to set the assetId field on the sequences it creates.\nIf createAssets is false, it will fail if it can't find the asset.\nIf createAssets is true, it will create the assets under the WellModelRoot asset.\nIf contextualizeAssets is set to false, it will not create assets even if createAssets is set to true.",
    )
    patterns: Optional[PatternConfig] = None
    items: List[SubmitJob]


class Pattern(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    __root__: Union[AnyOf, AllOf, Matches]


class AnyOf(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    any_of: List[Pattern] = Field(..., alias="anyOf")


class AllOf(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    all_of: List[Pattern] = Field(..., alias="allOf")


class PatternConfig(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    __root__: List[MeasurementPattern]


class MeasurementPattern(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measurement: str
    pattern: Pattern


SubmitRequest.update_forward_refs()
Pattern.update_forward_refs()
PatternConfig.update_forward_refs()
